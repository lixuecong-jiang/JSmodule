<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JSmodule</title>
    <script src="module.js"></script>
</head>
<body>
    <h2>原始写法</h2>
    <p>模块就是实现特定功能的一组方法，只要把不同的函数（）以及记录状态的变量简单地放在一起，就算是一个模块</p>
    <p>上面的函数m1()和m2()，组成了一个模块。使用的时候，直接调用就行了。这种做法的缺点很明显：“污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出来直接的关系。</p>
    <h2>对象写法</h2>
    <p>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面</p>
    <p>上面的函数m1()和m2(),都封装在module1对象里，使用的时候，就是调用这个对象的属性</p>
    <p>module1.m1()</p>
    <p>但是，这样的写法会暴露所有的模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值</p>
    <p>module1._count = 5;</p>
    <h2>立即执行函数写法</h2>
    <p>使用立即执行函数(Immediiately-Invoked Function Express,IIFE)，可以达到不暴露私有成员的目的</p>
    <p>使用上面这种写法，外部代码无法读取内部的__count变量</p>
    <p>console.log(module2._count);//</p>undefined
    <p>module2就是使用javascript模块的基本写法。下面，再对这种写法进行加工</p>
    <h2>放大模式</h2>
    <p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”</p>
    <p>上面的代码为module2模块添加一个新方法m3(),然后返回新的模块</p>
    <h2>宽放大模式</h2>
    <p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就是采用“宽放大模式”</p>
</body>
</html>